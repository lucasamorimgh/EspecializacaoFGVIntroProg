# -*- coding: utf-8 -*-
"""ListaProgramacao1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AvcLqTw__ylHfzQ6T-WiaEhxJ4YzktGZ
"""

#Lista 01 Parte 1 Questao 1
def pares_e_impares(nums):
  pares = []
  impares = []

  #Pecorre cada numero da lista nums e appenda na lista correta
  for n in nums:
    if n % 2 == 0:
      pares.append(n)
    else:
      impares.append(n)
  return [pares,impares]

pares_e_impares([2,3,4,6,7])

#Lista 01 Parte 1 Questao 2
def filtrar_por_tamanho(lista,k):
  resultado = []

  #Pecorre cada palavra da lista e appenda no resultado se satisfeita a condição de tamanho
  for palavra in lista:
    if len(palavra) > k:
      resultado.append(palavra)

  return resultado

filtrar_por_tamanho(["tupiniquim","ovo","oblongo", "oi"],3)

#Lista 01 Parte 1 Questao 3
def rotate_tuple(tpl,n):
  rot_list = list(tpl)

  #percorre cada indice de tpl e o reatribui shiftado em rot_list
  for i in range(len(tpl)):
    rot_list[(i+n) % len(tpl)] = tpl[i]
  return tuple(rot_list)

rotate_tuple((1,2,3,4,5), 7)

#Lista 01 Parte 1 Questao 4

def transpose(matrix):
  #define dimensões
  d_lin = len(matrix)
  d_col = len(matrix[0])

  #define matriz m com dimensões da transposta
  m = []
  for j in range(d_col):
    m.append(list("a"*d_lin))

  ##alternativamente, se fosse m definido como abaixo, daria problema, pois todas as entradas de m seriam identicas na memoria
  ##e não daria para altera-las entrada por entrada, alterar uma entrada em um faz identico nas demais
  #l =  list("a"*d_lin)
  #m = list([l]*d_col)

  #ajusta as entradas de m
  for i in range(d_lin):
    for j in range(d_col):
      m[j][i] = matrix[i][j]

  return m

transpose(((1,2,3),(4,5,6)))

#Lista 01 Parte 1 Questao 5

def flatten(lst):
  flatlst = []

  #percorre cada elemento de lst, se não for lista, appenda, se for a função é chamada em recorrencia
  for e in lst:
    if type(e) != type([]):
      flatlst.append(e)
    else:
      #o resultado da função chamada em recorrencia é uma lista, logo somamo-lo e não appendamo-lo
      flatlst = flatlst + flatten(e)
  return flatlst

flatten(["a","b",["c"],["d",["e"]]])

#Lista 01 Parte 2 Questao 1

def group_by(pairs):
  #forma as keys
  keys = []
  for p in pairs:
    if p[0] not in keys:
      keys.append(p[0])

  #forma a lista base do dicionario
  dct = []
  for k in keys:
    #para cada key, revisita pairs e appenda as entradas associadas para formar values_k
    values_k = []
    for p in pairs:
      if p[0] == k:
        values_k.append(p[1])
    #o par (k,values_k) é appendado no dct
    dct.append((k,values_k))

  return(dict(dct))

group_by([("A", 1), ("B", 1), ("C", 3), ("A", 4)])

#Lista 01 Parte 2 Questao 2
def invert_map(d):
  dct = []

  #percorre os itens da lista, inverte-os e appenda em dct
  for e in d.items():
    dct.append((e[1],e[0]))

  return dict(dct)

invert_map({"ano": 1992, "altura": 178, "nome": "Lucas"})

#Lista 01 Parte 2 Questao 3
def indices_of(lst):

  #entradas unicas de lst
  lst_unique = []
  for e in lst:
    if e not in lst_unique:
      lst_unique.append(e)

  dct = []
  for u in lst_unique:
    #para cada entrada unica u em lst_unique, definimos values_u, a lista de indices onde lst vale u
    values_u = []
    for i in range(len(lst)):
      if lst[i] == u:
        values_u.append(i)
    #juntamos os pares (u,values_u) em dct
    dct.append((u,values_u))

  return dict(dct)

indices_of(["oi","oi","xau"])

#Lista 01 Parte 2 Questao 4
def merge_dicts(dicts):

  #reune em allkeys todas as keys de todos os dicionarios
  allkeys = []
  for dct in dicts:
    for k in dct.keys():
      allkeys.append(k)

  #toma as entradas unicas de allkeys
  allkeys_unique = []
  for e in allkeys:
    if e not in allkeys_unique:
      allkeys_unique.append(e)

  #para cada entrada de allkeys_unique, percorre todos os dicionarios e todos seus valores, e vai somando quando a key bate
  dct_new = []
  for u in allkeys_unique:
    sum_u = 0
    for dct in dicts:
      for i in dct.items():
        if i[0] == u:
          sum_u = sum_u + i[1]
    dct_new.append((u,sum_u))

  return dict(dct_new)

merge_dicts([{"A": 1, "B": 1, "C": 3}, {"A": 4, "B": -4, "D": 2}] )

#Lista 01 Parte 2 Questao 5

def conta_digitos(n):
  #transforma numero em lista
  lst = list(str(abs(n)))

  #pega digitos unicos do numero
  lst_unique = []
  for e in lst:
    if e not in lst_unique:
      lst_unique.append(e)
  lst_unique.sort()

  #para cada digito unico, conta quantas ocorrencias
  result = []
  for u in lst_unique:
    u_count = 0
    for e in lst:
      if e == u:
        u_count = u_count + 1
    result.append((u,u_count))

  return result

conta_digitos(-9237638111)

#Lista 01 Parte 3 Questao 1

#funcção que pega uma string e retorna suas letras e ocorrências de suas letras
def contagem_letras(str):
  lst = list(str)
  #pega digitos unicos do numero
  lst_unique = []
  for e in lst:
    if e not in lst_unique:
      lst_unique.append(e)
  lst_unique.sort()

  #para cada digito unico, conta quantas ocorrencias
  result = []
  for u in lst_unique:
    u_count = 0
    for e in lst:
      if e == u:
        u_count = u_count + 1
    result.append((u,u_count))

  return result

#funçao que pega uma lista de duplas tipo (letra, numero) e retorna uma string com cada letra repetida pelo respectivo numero
def dic_to_str(lst):
  new = ""
  for i in lst:
    new = new + i[0]*i[1]
  return new

dic_to_str([('a', 1), ('o', 2), ('p', 1)])

def count_anagramas(words):
  #cada palavra é associada a uma lista que conta suas letras e respectivas ocorrencias
  words_with_counts = []
  for w in words:
    words_with_counts.append((w,contagem_letras(w)))

  #cria uma lista das listas que foram associadas as palavras do passo anterior
  counts = []
  for i in range(len(words_with_counts)):
    if words_with_counts[i][1] not in counts:
      counts.append(words_with_counts[i][1])

  #remove duplicatas de counts
  counts_unique = []
  for e in counts:
    if e not in counts_unique:
      counts_unique.append(e)
  counts_unique.sort()

  #para cada entrada de counts_unique identifica quais palavras da lista original são compativeis e registra em result
  result = []
  for u in counts_unique:
    values_u = []
    for w in words_with_counts:
      if u == w[1]:
        values_u.append(w[0])
    u_str = dic_to_str(u) #aqui consideramos a string associada a u
    result.append((u_str,values_u))

  return dict(result)

count_anagramas(["bolo", "lobo", "arara", "arara", "pao", "opa"])

#Lista 01 Parte 3 Questao 2

def parse_csv(text, sep=","):
  #identifica o numero de colunas do csv
  ncol = len(text.split("\n")[1].split(sep))

  #para cada coluna, identifica o header (key) e o valores a ela associados (em lista) e guarda esses pares em dctlist
  dctlist = []
  for col in range(ncol):
    values_col = []
    for row in range(len(text.split("\n"))):
      if row == 0:
        key_col = text.split("\n")[row].split(sep)[col]
      else:
        values_col.append(text.split("\n")[row].split(sep)[col])
    dctlist.append((key_col, values_col))

  #transforma dctlist em dicionario e retorna
  return(dict(dctlist))

parse_csv("Altura, Nome, Idade \n 177, Pedro, 21 \n 191, Carlos, 33 \n 169, Alice, 23")

#Lista 01 Parte 3 Questao 1

#função auxiliar que pega uma matrix 3x3 e retorna maior qtd de digitos repetidos ela tem
def validar_submatrix(mtx):
  #percorre cada entrada da matrix e as coluna numa lista unica
  singlelist = []
  for i in range(len(mtx)):
    for j in range(len(mtx)):
      singlelist.append(mtx[i][j])

  #varre cada digito, registrando sempre a maior frequencia observada em count
  count = 0
  for n in range(9):
    count = max(count, singlelist.count(n+1))

  return(count)

#função principal, verifica se restrições de validade de uma matriz de sudoku estão atendidas
def validar_sudoku(tabuleiro):

  #transpoe o tabuleiro
  transp_tabuleiro = transpose(tabuleiro)
  count = 0

  #varre as linhas do tabuleiro e sua transposta
  for i in range(len(tabuleiro)):
    # e varre cada digito, registrando sempre a maior frequencia observada em count
    for n in range(9):
      count = max(count, tabuleiro[i].count(n+1),transp_tabuleiro[i].count(n+1))

  for j in range(3):
    row_beg = j*3
    row_end = (j+1)*3
    for k in range(3):
      col_beg = k*3
      col_end = (k+1)+3
      tabuleiro_jk = tabuleiro[row_beg:row_end]
      count = max(count, validar_submatrix(tabuleiro_jk))

  if count>1:
    resposta = False
  else:
    resposta = True
  return(resposta)


tabuleiro = [
    [5, 3, 4, 6, 7, 8, 9, 1, 2],
    [6, 7, 2, 1, 9, 5, 3, 4, 8],
    [1, 9, 8, 3, 4, 2, 5, 6, 7],
    [8, 5, 9, 7, 6, 1, 4, 2, 3],
    [4, 2, 6, 8, 5, 3, 7, 9, 1],
    [7, 1, 3, 9, 2, 4, 8, 5, 6],
    [9, 6, 1, 5, 3, 7, 2, 8, 4],
    [2, 8, 7, 4, 1, 9, 6, 3, 5],
    [3, 4, 5, 2, 8, 6, 1, 7, 9]
]
validar_sudoku(tabuleiro)