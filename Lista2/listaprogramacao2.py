# -*- coding: utf-8 -*-
"""ListaProgramacao2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hHrqpb2j9zUYw9AaPLDDy95KSAvyNSQC
"""

#Lista 02 Parte 1 Questao 1
def future_value(pv, r, n, t):
  """
  Função que calcula o valor futuro.

  Args:
    pv (float): valor presente
    r (float): juros anual
    n (int): número de capitalizações por ano
    t (float): número de horizontes no ano

  Returns:
    float: valor futuro

  Example:
    >>> future_value(100,0.1,2,2)
    121.55
  """
  futurevalue = pv * (1 + r/n) ** (n*t)

  return futurevalue.__round__(2)

future_value(100,0.1,2,2)

#Lista 02 Parte 1 Questao 2
def standard_deviation(returns):
  """
    Função que calcula o desvio padrão populacional.

  Args:
    returns (list): lista de retornos observados (float)

  Returns:
    float: desvio padrão populacional dos retornos observados

  Example:
    >>> standard_deviation([0.1,0.2])
    0.05
  """
  #número de observações
  N = len(returns)

  #media dos retornos
  sum = 0
  for x in returns:
    sum += x
  xbar = sum / N

  #variancia populacional
  sum2 = 0
  for x in returns:
    sum2 += (x - xbar)**2
  var = sum2 / N
  desvpad = (var)**0.5

  return desvpad

standard_deviation([0.1,0.2])

#Lista 02 Parte 1 Questao 3
import math

def time_to_double(r):
  """
    Função que calcula o tempo que um capital demora a debobrar mediante juros r.

  Args:
    r (float): taxa de juros em dado período (eg, anualizada)

  Returns:
    float: tempo que um capital demora a debobrar, em quantidades do período dado (eg, número de anos)

  Example:
    >>> time_to_double(0.1)
    7.27
  """

  #calcula o doubling time
  t = math.log(2) / math.log(1+r)

  return t.__round__(2)

time_to_double(0.1)

#Lista 02 Parte 2 Questao 1
import itertools

def portfolio_combinations(assets, k):
  """
    Função que retorna a lista de k-combinações dentre os ativos listados em assets.

  Args:
    assets (list): lista de ativos (strings)
    k (int): tamanho dos subconjuntos de interesse

  Returns:
    list: lista de k-combinações dentre os ativos listados em assets

  Example:
    >>> portfolio_combinations(["PETR3","PETR4","ABEV3","VALE3"],3)
    [('PETR3', 'PETR4', 'ABEV3'), ('PETR3', 'PETR4', 'VALE3'), ('PETR3', 'ABEV3', 'VALE3'), ('PETR4', 'ABEV3', 'VALE3')]
  """

  return list(itertools.combinations(assets,k))

portfolio_combinations(["PETR3","PETR4","ABEV3","VALE3"],3)

#Lista 02 Parte 2 Questao 2
from collections import deque
from itertools import islice

#Obtido da documentação do itertools
def sliding_window(iterable, n):
    "Collect data into overlapping fixed-length chunks or blocks."
    # sliding_window('ABCDEFG', 4) → ABCD BCDE CDEF DEFG
    iterator = iter(iterable)
    window = deque(islice(iterator, n - 1), maxlen=n)
    for x in iterator:
        window.append(x)
        yield tuple(window)

#Media
def media(lista):
  """
  Função que retorna a média de uma lista numérica

  Args:
    lista (list): lista de números (floats)

  Returns:
    float: média da lista numérica
  """

  #número de observações
  N = len(lista)

  #media
  sum = 0
  for x in lista:
    sum += x

  if N > 0:
    xbar = sum / N
  else:
    xbar = None

  return xbar

def moving_average(prices, window):
  """
  Função que retorna as médias móveis de tamanho "window" sobre a lista "prices"

  Args:
    prices (list): lista de preços ordenados no tempo (floats)
    window (int): tamanho da janela móvel

  Returns:
    list: lista das médias móveis (floats)

    Example:
    >>> moving_average([100,102,101,103], 3)
    [101.0, 102.0]
  """
  medias = []
  for tupla in sliding_window(prices, window):
    medias.append(media(tupla))

  return medias

moving_average([100,102,101,103], 3)

#Lista 02 Parte 3 Questao 1
import random

def simulate_stock_price(initial_price, mu, sigma, days):
  """
  Função que retorna uma lista com "initial_price" seguido de tantos dias de simulação quanto em "days",
  com incrementos normais com média "mu" e desvio padrão "sigma"
  Resultado aleatório.

  Args:
    initial_price (float): preço inicial
    mu (float): media do incremento normal
    sigma (float): desvio padrão do incremento normal, deve ser não negativo
    days (int): número de dias no horizonte de risco

  Returns:
    list: lista com initial_price seguindo dos preços simulados
  """

  precos = [initial_price]
  for i in range(days):
    novopreco = precos[i] + random.gauss(mu,sigma)
    precos.append(novopreco.__round__(2))

  return precos

simulate_stock_price(100,0,1,5)

#Lista 02 Parte 4 Questao 1
import urllib
import os
import csv

def download_and_merge(years_quarters, output_file):
  """
  Função que baixa e concatena os csvs da BLS QCEW para os períodos indicados e salva na root

  Args:
    years_quarters (list): lista de anos e quarters, no formato [(2024, 1), (2024, 2)]
    output_file (string): nome do arquivo destino, no formato nome.csv
  """

  #limpa/cria diretório "data"
  if not os.path.isdir("data"):
    os.makedirs("data")
  for f in os.listdir("data"):
    os.remove(f"data/{f}")
  if os.path.exists(output_file):
    os.remove(output_file)

  #percorre as periodos indicados e coleta os dados
  for year_quarter in years_quarters:
    year = year_quarter[0]
    quarter = year_quarter[1]
    url = f"https://data.bls.gov/cew/data/api/{year}/{quarter}/industry/10.csv"
    urllib.request.urlretrieve(url,f"data/{year}_q{quarter}.csv")

  output = []

  #lista de arquivos no diretório "data"
  arxivs = os.listdir("data")
  arxivs.sort

  #abre cada arquivo e junta seu conteudo em "output", sendo apenas o primeiro com header
  for f in enumerate(arxivs):
    with open(f"data/{f[1]}", 'r') as csv_origem: #sessão para leitura de csv
      leitor_csv = csv.reader(csv_origem) #objeto leitor de csv
      if f[0] == 0:
        for linha in leitor_csv:
          output.append(linha)
      else:
        next(leitor_csv) #pula a primeira linha (header) do csv
        for linha in leitor_csv:
          output.append(linha)

  #salva o conteudo de "output" como csv no output_file
  with open(output_file, 'w', newline='') as csv_destino:
      writer = csv.writer(csv_destino)
      writer.writerows(output)

download_and_merge([(2024, 1), (2024, 2)], "resultadofinal.csv")